# Способы оптимизации вычислений

## Задание 1

### Однократное вычисление значений тригонометрических функций

В рамках каждой итерации цикла значения *sin(a)* и *cos(a)* используются дважды. Простейший способ оптимизации 
в данной случае - однократное вычисление синуса и косинуса в начале итерации и использование в вычислениях
*t1* и *t2* переменных, содержащих полученные значения

### Векторизация вычислений

Вместо многократного вычисления значений *t1* и *t2* на каждой итерации можно однократно воспользоваться векторными
функциями библиотеки [NumPy](https://numpy.org): задать случайные вектора значений *a*, *x* и *y*,
затем векторно вычислить значения синусов и косинусов и произвести операции сложения и умножения массивов

### Внутреннее распараллеливание цикла

Одним из способов распараллеливания данной задачи является внутреннее распараллеливание цикла с помощью
библиотеки [mpi4py](https://mpi4py.readthedocs.io/en/stable/):
на каждой итерации цикла значения *a*, *x* и *y* случайно генерируются в рамках родительского процесса,
затем передаются дочерним процессам, вычисляющим *t1* и *t2*. После окончания вычислений дочерние 
процессы возвращают полученные значения родительскому процессу, запускающему новую итерацию цикла

### Внешнее распараллеливание цикла

Альтернативным способом распараллеливания данной задачи является внешнее распараллеливание цикла
с помощью библиотеки [mpi4py](https://mpi4py.readthedocs.io/en/stable/):
каждый дочерний процесс проводит внутри себя часть итераций цикла и после завершения своей части общей работы
посылает родительскому процессу сигнал об этом

## Задание 2

### Типизация данных

Первым способом оптимизации является использование различных типов данных в рамках программы в силу того,
что вычисления затрачивают различное время при различных типах входных данных. Для этого в рамках
программного кода для второго задания используются типы данных int и float

### Использование библиотеки Numpy

Библиотека [NumPy](https://numpy.org) предоставляет набор функций, оптимизированных для работы с 
векторами и матрицами. Т.к. NumPy исполняется на базе заранее скомпилированного кода на языке C,
скорость выполнения ее функций выше, нежели у кода, написанного на чистом Python

### Распараллеливание цикла вычислений

Данную задачу можно распараллелить с помощью библиотеки [mpi4py](https://mpi4py.readthedocs.io/en/stable/)
следующим образом: родительский процесс рассылает дочерним процессам складываемые массивы. Каждый
из дочерних процессов выполняет суммирование своего "блока", после чего посылает результат 
(подмассив результирующего массива) родительскому процессу.
Родительский процесс же собирает полученные подмассивы и выстраивает из них единый результирующий массив.

## Способы исполнения кода

### Стандартная интерпретация

Обычным способом исполнения программ, написанных на Python, является интерпретация при помощи
стандартного интерпретатора языка. Т.к. Python является интерпретируемым языком - это существенно сказывается на его производительности

### JIT компиляция с помощью Numba 

Для ускорения работы программы код, написанный на Python, можно скомпилировать JIT компилятором [Numba](https://numba.pydata.org) 
путем добавления аннотаций к функциям внутри программного кода

### JIT компиляция с помощью Pypy

Альтернативным компилятором для Python является [Pypy](https://www.pypy.org)